{"pages":[],"posts":[{"title":"C# .Net CodeFist编码基础流程","text":"Code First 基础流程 1. 定义好实体类（对应数据库的表及其字段） 2. 定义好上下文操作类（以context结尾） 12345678910//在该项目上右键找到“管理 NuGet程序包” 搜索EntityFrameWork并下载好public nCovContext() : base(&quot;name=aa&quot;) // 声明连接字符串{}// 注册实体类 public DbSet&lt;tbStudent&gt; tbStudent { get; set; }public DbSet&lt;tbTeacher&gt; tbTeacher { get; set; }public DbSet&lt;tbDetail&gt; tbDetail { get; set; } 3. 在App.config里加上数据库连接字符串 123&lt;connectionStrings&gt; &lt;add name=&quot;aa&quot; connectionString=&quot;server=.;database=nCov3804DB;uid=sa;pwd=123456&quot; providerName=&quot;System.Data.SqlClient&quot; /&gt;&lt;/connectionStrings&gt; 【注意: 上下文操作类的构造方法的name=”aa”要与App.config的name=aa保持一致】 Code First模式默认的约定 主键约定： 以ID或者是类型ID的字段会自动生成为主键。如果是Int类型，会默认为自增 表名约定：跟类名一样，会默认加上一个s 一对多的约定：导航属性。 字符串约定：string =&gt; nvarchar(Max),默认允许为空","link":"/2020/06/17/CSharp%20.Net%20CodeFist%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/"},{"title":"C# 索引器","text":"索引器的定义 索引器允许类或结构的实例就像数组一样进行索引。 无需显式指定类型或实例成员，即可设置或检索索引值。 索引器类似于属性，不同之处在于它们的访问器需要使用参数。 索引器的使用场景 不知道各位是否有遇到过这样一种情况，我们基于一个类或继承于同一个父类或接口的类，实例化多个对象，却无法进行统一的管理和定义。即使是利用 List 进行管理，依旧有很多不方便和局限的地方。 索引器的出现，就是为了解决这个问题，它允许类或结构的实例就像数组一样进行索引。 索引器的 C# 实现简单例子定义索引器12345678910111213141516// 定一个索引器SimpleCollectionpublic class SimpleCollection&lt;T&gt;{ // 定一个数组，转载这些传入的数据 private T[] arr = new T[100]; // 定义一个属性，用于获取数组的长度 public int Length =&gt; arr.Length; // 定义一个索引器，允许使用[]对数据进行索引 public T this[int i] { get =&gt; arr[i]; set =&gt; arr[i] = value; }} 定义一个需要使用索引器的类123456789// 定义一个Car类public class Car{ public string name; public Car(string name) { this.name = name; }} 索引器的使用12345678910111213141516171819202122public static void Main(string[] args){ SimpleCollection&lt;Car&gt; simple = new SimpleCollection&lt;Car&gt;(); simple[0] = new Car(&quot;Car&quot;); simple[1] = new Car(&quot;Car1&quot;); simple[2] = new Car(&quot;Car2&quot;); simple[3] = new Car(&quot;Car3&quot;); simple[4] = new Car(&quot;Car4&quot;); for (int i = 0; i &lt; simple.Length; i++) { Console.WriteLine(simple[i].name); }}/*输出以下内容：CarCar1Car2Car3Car4*/ 索引器实际使用 在更多的时候，我们不会像上面的实例一样去写索引器。更多的时候，是索引器的定义内，加入一些对数据进行处理的方法。 例如上面的例子，我们希望可以讲输出car属性的方法，内置在索引器内。 定义新的索引器123456789101112131415161718192021222324252627// 定一个索引器SimpleCollectionpublic class SimpleCollection&lt;T&gt; where T:Car{ // 定一个数组，转载这些传入的数据 private T[] arr = new T[100]; // 定义一个属性，用于获取数组的长度 public int Length =&gt; arr.Length; // 定义一个索引器，允许使用[]对数据进行索引 public T this[int i] { get =&gt; arr[i]; set =&gt; arr[i] = value; } /// &lt;summary&gt; /// 输出所有方法的name属性的值 /// &lt;/summary&gt; public void SayAllName() { for (int i = 0; i &lt; arr.Length; i++) { Console.WriteLine(arr[i].name); } }} 上面这段新的代码，除了新增了一个 SayAllName 的方法之外，还有一个细节，在第一行，多了个 **where T : Car，这个是为了约束这个索引器的泛型只能是继承于 Car 的类。这样，就相当于，告诉当前索引器，索引器索引的实例继承于 Car 类，所以可以在使用 Car 所允许继承的方法和属性**。 索引器的使用12345678910111213141516171819public static void Main(string[] args){ SimpleCollection&lt;Car&gt; simple = new SimpleCollection&lt;Car&gt;(); simple[0] = new Car(&quot;Car&quot;); simple[1] = new Car(&quot;Car1&quot;); simple[2] = new Car(&quot;Car2&quot;); simple[3] = new Car(&quot;Car3&quot;); simple[4] = new Car(&quot;Car4&quot;); simple.SayAllName();}/*输出以下内容：CarCar1Car2Car3Car4*/ 由此可见，依旧可以完成我们预期的任务。但这样，可以让主函数的逻辑更加清晰明了，也方便了继承于 Car 或 Car类 的所有实例，可以使用他们共用的一种方法 SayAllName。这能大大加快了我们的编码效率。 所以，建议在日常的开发中，对需要一起操作的多个同父的类，多使用索引器，加快自己的开发效率。","link":"/2020/08/23/CSharp%20%E7%B4%A2%E5%BC%95%E5%99%A8%20/"},{"title":"CentOS单机部署Kubernetes","text":"CentOS单机部署Kubernetes第一步，安装etcd和kubernetes Kubernetes中几乎所有的资源对象（Node、Pod、Replication Controller、Service等）都能通过kubectl工具执行增删改查操作并保存在etcd中持久化存储，因此Kubernetes和etcd密不可分，又由于Kubernetes高度依赖Docker，所以安装途中会自动安装Docker 1sudo yum install -y etcd kubernetes 第二步，按顺序启动所有相关服务 按顺序启动所有相关服务1234567systemctl start etcdsystemctl start dockersystemctl start kube-apiserversystemctl start kube-controller-managersystemctl start kube-schedulersystemctl start kubeletsystemctl start kube-proxy 开机启动所有相关服务1234567systemctl enable etcdsystemctl enable dockersystemctl enable kube-apiserversystemctl enable kube-controller-managersystemctl enable kube-schedulersystemctl enable kubeletsystemctl enable kube-proxy 查询服务启动状态1234567systemctl status etcdsystemctl status dockersystemctl status kube-apiserversystemctl status kube-controller-managersystemctl status kube-schedulersystemctl status kubeletsystemctl status kube-proxy 查看Kubernetes集群启动情况1kubectl get nodes 如果只有一个节点表示单例安装成功 12NAME STATUS AGE127.0.0.1 Ready 31m","link":"/2022/01/20/CentOS%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2Kubernetes/"},{"title":"Docker安装单例Nacos，并连接MySQL","text":"Docker安装单例Nacos，并连接MySQL前提条件已经安装Docker、MySQL 第一步，下载nacos-server的Docker镜像1docker pull nacos/nacos-server 第二步，初始化MySQL的Nacos配置储存数据表创建一个数据库nacos_config1CREATE DATABASE nacos_config; 下载并运行数据库初始化DDL语句 https://github.com/alibaba/nacos/blob/develop/distribution/conf/nacos-mysql.sql 第三步，运行Docker镜像 1docker run -d -e MODE=standalone -e SPRING_DATASOURCE_PLATFORM=mysql -e MYSQL_SERVICE_HOST=xxx.xxx.xxx.xxx -e MYSQL_SERVICE_PORT=3306 -e MYSQL_SERVICE_USER=xxxxx -e MYSQL_SERVICE_PASSWORD=xxxxxx -e MYSQL_SERVICE_DB_NAME=nacos_config -p 8848:8848 --restart=always --name nacos nacos/nacos-server 上面的docker运行脚本语句中有几个参数需要修改： MYSQL_SERVICE_HOST： MySQL数据库的IP地址或者域名 MYSQL_SERVICE_PORT：MySQL数据库的端口号，MySQL数据库默认端口号为3306 MYSQL_SERVICE_USER：MySQL的登录名 MYSQL_SERVICE_PASSWORD：MySQL的登陆密码 MYSQL_SERVICE_DB_NAME：MySQL的Nacos配置储存数据表名，如果按照第二步，那就应该值为nacos_config","link":"/2022/01/11/Docker%E5%AE%89%E8%A3%85%E5%8D%95%E4%BE%8BNacos%EF%BC%8C%E5%B9%B6%E8%BF%9E%E6%8E%A5MySQL/"},{"title":"Docker配置国内镜像","text":"Docker配置国内镜像 为加快拉取镜像速度，我们可以设置docker国内镜像源 常用国内Docker镜像地址 科大镜像：https://docker.mirrors.ustc.edu.cn/ 网易：https://hub-mirror.c.163.com/ 七牛云加速器：https://reg-mirror.qiniu.com 阿里云：https://&lt;你的ID&gt;.mirror.aliyuncs.com 修改Docker配置文件创建或修改 /etc/docker/daemon.json 文件，修改为如下12345678{ &quot;registry-mirrors&quot; : [ &quot;https://registry.docker-cn.com&quot;, &quot;https://docker.mirrors.ustc.edu.cn&quot;, &quot;http://hub-mirror.c.163.com&quot;, &quot;https://cr.console.aliyun.com/&quot; ]} 重启Docker服务1systemctl restart docker.service","link":"/2021/07/11/Docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/"},{"title":"JavaScript设计模式——Observe模式（观察者模式）","text":"通常一个优秀的项目，会使用到很多的设计模式，这些设计模式在我们的解决方案中，会起到十分重要的作用，它的存在，能使项目的结构更加简洁、清晰、易于理解。所以了解常用的设计模式，会让我们在日常开发更加得心应手，也会让团队沟通变得更加顺畅。在《设计模式：可复用面向对象软件基础》一书中强调：**当我们评估一个面向对象系统的质量时，所使用的方法之一就是判断系统的设计者是否强调了对象之间的公共系统关系**。 简介那么在当前这个博文中，我介绍的就是 JavaScript 语言的 Observer设计模式。初次接触 Observer设计模式，是在 Vue 的双向数据绑定中。其原理就是使用了 Observer-观察者 对数据进行劫持，然后让数据的读写全部处于监管之中。然后再使用发布-订阅模式的Publish-发布者通知到Subscribe-订阅者，对数据进行进行相应操作，比如双向数据绑定中的视图更新。 所以，Vue的一个数据的写入，要经过这样一个流程。 所以，实际上，Vue 数据的双向绑定，使用到了2个设计模式：Obsever模式和Publish–Subscribe模式。(有一些人认为，观察者模式和订阅观察模式是一个模式，其实不然，他们还是有一些区别的) Observer模式（观察者模式） 就像发明一个新的东西一样，新的发明，必定会有其在现实世界的启发。就好比雷达的发明，源自于蝙蝠的超声波回声定位。火箭的发明，源自于水母、墨鱼的反冲运动。 无独有偶，观察者模式也一样。在现实社会中，经常会出现观察者这个身份。比如书店，他们就是观察者。既然，有了观察者，那一定会有被观察者，他们就像是出版社。书店“监视”各个出版社的新书，若出版社出现了新书（观察者在监视的行为），则书店获得了出版社的信息（被观察者的对象信息）和出版社的发布新书（被观察者的变化），然后书店将其发布的新书拿到，并告诉关注该类书的读者（观察者做出相应操作） Observer模式的大致流程如上。话不多说，我们着手开始用 JavaScript 实现Observer模式。 设计模式中的对象Observer 观察者 Observer是一个监视被观察者的对象，它需要提供一个接口，对数据发生改变时，做出的行为进行定义。 Subject 被观察者 在出现观察者关心的事件时，要同时通知多个观察者。 抽象模型的代码实现Observer 观察者123456var Observer = function () {};// 观察者包含一个notify(通知)的回调方法Observer.prototype.notify = function (info) { // 在该方法内做出操作 console.log(`观察者发现 ${info} 出现更改`);}; Subject 被观察者123456789101112131415161718192021222324252627282930313233343536var Subject = function (info) { // 注册自己（被观察者）的信息 this.info = info; // 已经注册的观察者的列表 this.observerList = [];};Subject.prototype = { // 注册一个监视当前对象的观察者到观察者列表 register: function (observer) { this.observerList.push(observer); }, // 不在关注当前对象的观察者，注销观察者对象 remove: function (observer) { // 获得当前观察者列表的长度 var listLength = this.observerList.length; for (var i = 0; i &lt; listLength; i++) { if ((observer = this.observerList[i])) { // 从观测者列表删除该观察者 this.observerList.splice(i, 1); return true; } } return false; }, // 通知所有注册的观察者对象 update: function () { var observer; // 获得当前观察者列表的长度 var listLength = this.observerList.length; for (var i = 0; i &lt; listLength; i++) { observer = this.observerList[i]; // 调用Observer对象的notify回调方法 observer.notify(this.info); } },}; 小结 以上便是Observer模式的代码实现雏形，主要的流程和逻辑已经包括在其中了。但是在具体实现的时候，可以做出部分的调整。 比如： 1observer.notify(this.info); 这一句代码可以不一定要传输对象自身的所有信息，放在出版社那，可能只需要传入一个新发布的书名。 那么接下来，我们按照之前的出版社-书店-读者的例子，进行一个具体实例的代码实现。 具体实例的代码实现Observer 观察者(书店) 定义123456var BookStore = function () {};// 书店包含一个notify(通知)的回调方法BookStore.prototype.notify = function (CompanyName,BookName) { // 在该方法内做出操作 console.log(`读者快来，我这出了新书：${CompanyName} 发版的 ${BookName}`);}; Subject 被观察者(出版社) 定义12345678910111213141516171819202122232425262728293031323334353637383940var Company = function (CompanyName) { // 出版社名称 this.Name = CompanyName; // 新的书名 this.NewBookName = &quot;&quot;; // 已经注册的书店的列表 this.bookStoreList = [];};Company.prototype = { // 注册一个监视当前对象的书店到书店列表 register: function (bookStore) { this.bookStoreList.push(bookStore); }, // 不在关注当前对象的书店，注销书店对象 remove: function (bookStore) { // 获得当前书店列表的长度 var listLength = this.bookStoreList.length; for (var i = 0; i &lt; listLength; i++) { if ((bookStore == this.observerList[i])) { // 从书店列表删除该观察者 this.bookStoreList.splice(i, 1); return true; } } return false; }, // 通知所有注册的书店对象 publish: function (BookName) { // 记录新发布书的名字 this.NewBookName = BookName; var bookStore; // 获得当前书店列表的长度 var listLength = this.bookStoreList.length; for (var i = 0; i &lt; listLength; i++) { bookStore = this.bookStoreList[i]; // 调用BookStore对象的notify回调方法 bookStore.notify(this.Name,this.NewBookName); } },}; 具体使用1234567891011121314151617181920212223242526272829303132// 初始化一个出版社——VicoHu出版社var company = new Company(&quot;VicoHu出版社&quot;);// 初始化三家商店var bookStore1 = new BookStore(&quot;小胡书店&quot;);var bookStore2 = new BookStore(&quot;二刘书店&quot;);var bookStore3 = new BookStore(&quot;大黄书店&quot;);// 重写bookStore3的notify方法实现发布新书时的不同操作bookStore3.notify = function (CompanyName, BookName) { // 在该方法内做出操作 console.log( `${this.Name}促销，新书上架：${CompanyName} 发版的 ${BookName}，比其他的店都要便宜很多。` );};// 将三家商店注册到出版社的商店列表里company.register(bookStore1);company.register(bookStore2);company.register(bookStore3);// 发布新书company.publish(&quot;《挪威的森林》&quot;);// 控制台输出如下内容/** * 小胡书店有促销活动!!!!! 读者快来，我这出了新书：VicoHu出版社 发版的 《挪威的森林》 * 二刘书店有促销活动!!!!! 读者快来，我这出了新书：VicoHu出版社 发版的 《挪威的森林》 * 大黄书店促销，新书上架：VicoHu出版社 发版的 《挪威的森林》，比其他的店都要便宜很多。 */ 小结在上面的具体实例的代码实现中，我们完成了书店的创建，和出版社的创建，并且将多个商店注册到出版社，并在出版社发布新书的时候，通知给所有的商店，让商店发出广告和通知给我们（读者）。其实，从本质上而言，商店（观察者）是被动的，它需要依赖于出版社（被观察者）调用notify方法，来完成商店的广告发布。但是，商店的广告的发布，可以通过重写 notify 方法来进行自定义的操作。 总结Observer 设计模式的优点和缺点都比较明显。 Observer模式 优点 解耦。这是现在大多数的设计模式都在做的一件事情，例如：MVC、MVVM等。其好处就在于，不需要在设计观察者的时候，关注被观察者的设计。这样可以只需要关注一个notify方法的参数。这样的好处很明显，可以把更多的注意力放在设计某个对象的上面。 广播通讯。如我们后面发布的 《挪威的森林》一书，只需要调用一出版社的publish方法，就可以对所有已经在出版社注册的商店进行通知。 Observer模式 缺点 观察者过于被动。观察者在这个设计中，其实更像是个被通知的身份，它没有主动了解被观察者的能力。只能根据观察者给的信息，做出反应和操作。 抗风险性不高。假如某个注册的商店的方法出现问题，或者一直未执行完，会影响到后面的商店的通知。从而影响整体广播的执行。 最后的总结 这世界上没有绝对通用的设计模式，都是根据任务的需求，选择合适的设计模式。但是，倘若你连某个合适的设计模式都不知道，就会错过一些事半功倍的机会。所以，只有不断的去学习，不断走出舒适圈，才能让自己走的更远，并成为一个编码更加高效、稳定的开发者。加油吧！各位！","link":"/2020/07/17/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94Observe%E6%A8%A1%E5%BC%8F%EF%BC%88%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%89/"},{"title":"Java中抽象类和接口的分析","text":"Java中抽象类和接口的分析接口的分析简介接口在JAVA中是一个抽象类型，一般是抽象方法的集合（也可包含空指针变量）。一个类通过继承接口的方式，从而来继承接口的抽象方法。 接口也一般作为一系列行为的抽象，它不是某个对象的本质is-a，而是一个对象has-a某个或多个接口的行为。 所以，一个对象是可以实现多个接口的。 这就像是一台空调，它是is-a一个制冷器，它has-a除湿、加热的功能。 Java8的default方法出现前的问题 记忆中，很多的编程语言在早期的学习中，都会有老师或者文档告诉我们，接口只定义行为，是不能有具体实现的，而抽象类是可以有具体实现的。这样的设计，似乎可以更好的诠释abstract class的is-a与interface的has-a特性的界限，但是随着软件项目的不断成长，这问题也慢慢彰显出来。 在实际的项目开发中，我们会发现一个问题，在一个已经设计完成的Interface中，再增加一个方法的话，会需要改动其所有的实现类，这对于项目的维护是近乎毁灭性的。 比如，java.util.List接口，如果我需要增加一个方法的话（不止图中显示的，滚动滚动条下面还有很多），下图中的所有实现类，全部都要实现这个新增的方法。 可能 Java设计者也意识到了这个问题，于是在Java8中增加了Interface的default方法，default方法允许你在接口中提供一些方法的默认实现。 接口的实际使用场景根据《Java编程思想》一书中提到的类接口关系概念： is-a：继承关系。例如，空调是制冷机，放在编程语言中就是，空调is-a制冷机。所以，空调的本质就是制冷机。其关系如下图 classDiagram Refrigerator","link":"/2022/01/27/Java%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%88%86%E6%9E%90/"},{"title":"LeetCode——会议室 II——动态规划","text":"会议室 II给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si &lt; ei)，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。 示例 1: 12输入: [[0, 30],[5, 10],[15, 20]]输出: 2 示例 2: 12输入: [[7,10],[2,4]]输出: 1 这个题目有点类似于上下车问题。本题是规划的对于时间冲突的解决方案。根据题目，我们发现，并不需要在意该会议持续时间。因为会议时间已经固定了，所以我们只需要关注会议室及其会议结束时间即可。因为只有会议时间结束，才能进行下一个会议。否则，这需要开一个新的会议室，去进行会议。为了最优开会成本和时间效率，下一个会议进入的房间，根据会议室结束时间和该会议开始时间的差决定，时间差越小，开会越能“无缝连接”，于是效率越高。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution { public int minMeetingRooms(int[][] intervals) { if(intervals == null || intervals.length ==0) return 0; // 根据会议开始时间，数组的重新排序（开始时间的从小到大） Arrays.sort(intervals,new Comparator&lt;&gt;(){ @Override public int compare(int[] o1, int[] o2) { return o1[0]-o2[0]; } }); // 定义一个HashMap记录会议室及其结束时间 Map&lt;Integer,Integer&gt; RoomTime = new HashMap&lt;&gt;(); // 第一个开始会议的已经毋庸置疑，就是开会时间最早的那个会议，也就是排序后的第一个会议 RoomTime.put(1,intervals[0][1]); // 定义一个表示符号，用于后面的forEach跳过第一个会议，因为第一个会议已经安排好了 boolean isFirst = false; for(int[] item :intervals){ if(!isFirst) { // 跳过第一个会议，因为已经安排了 isFirst = !isFirst; continue; } // 时间差 int fix = 0; // 该会议，目前临时安排的房间 int tempRoom = 0; // 循环所有会议室 for(Map.Entry&lt;Integer,Integer&gt; entry: RoomTime.entrySet()){ // 如果时间上满足要求 if(entry.getValue() &lt;= item[0]) { // 取最优的会议室给当前会议 if(fix == 0 || item[0] - entry.getValue() &lt;= fix) { fix = item[0] - entry.getValue(); tempRoom = entry.getKey(); } } } // 如果临时间号不为0，则有房间满足要求。否则，说明没有房间满足要求，需要开一个新的会议室，安排该会议 if(tempRoom != 0) RoomTime.put(tempRoom, item[1]); else RoomTime.put(RoomTime.size() + 1,item[1]); } // 最后返回房间的数量，即是本题的答案 return RoomTime.size(); }}","link":"/2020/05/26/LeetCode%E2%80%94%E2%80%94%E4%BC%9A%E8%AE%AE%E5%AE%A4%20II%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"LeetCode——打家劫舍问题——动态规划","text":"打家劫舍问题你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。 示例 1: 1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 对于求最优解得题目，我编码效率最快的，自然是递归，但是，递归在数组的长度越来越长是，所需的世界也会飞速增长。因为递归进行了很多重复的运算。对于本题而言，或许动态规划更加适合当前题目的情景。根据题目规则我们可以得到几个信息。 Opt[i] = （ Opt[i - 2] + Nums[i] ） 或者 （Opt[i - 1]） i为第i个元素，opt[i]为第i个及其之前的元素的最优解（不考虑之后的元素，只考虑当前元素和之前的元素），Nums为传入的数组 123456789101112131415161718192021222324252627282930313233343536class Solution { public int rob(int[] nums) { int y = 0, n = 0; // 初始化2个变量，代表着选取该节点和不选取该节点。y: yes, n: no int[] opt = new int[nums.length]; // 初始化一个数组，用于存储每个节点的当前元素及其之前元素的最优解（不管之后的元素 是否选择） if (nums.length == 0) { // 如果传入的数组为空，返回值为0 return 0; } if (nums.length == 1) { // 如果传入的值为1，返回值为当前数组的唯一元素 return nums[0]; } // 如果，满足传入数组的长度大于等于2 opt[0] = nums[0]; opt[1] = Math.max(nums[0],nums[1]); // 第一个元素及之前元素的最优解为第一个元素本身 // 第二个元素及之前元素的最优解为第一个元素或者第二个元素（取大值） for(int i = 2;i &lt;= nums.length - 1; i++ ) { // 循环计算，2和2之后每一个元素及之前元素的最优解 // 每个节点都会遇到2个可能，需要当前元素和不需要当前元素 y = nums[i] + opt[i - 2]; n = opt[i - 1]; opt[i] = Math.max(y,n); // 取最优解 } Arrays.sort(opt); // 对最优解进行排序，取最大值即为当前题目的最优解 return opt[nums.length - 1]; // 返回排序后最后一个元素（最大的元素） }}","link":"/2020/05/27/LeetCode%E2%80%94%E2%80%94%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"title":"Spring Cloud打包Docker镜像到Harbor","text":"Spring Cloud打包Docker镜像到Harbor 随着分布式系统的不断流行和发展，分布式系统的优点也越来越明显： 易于开发和维护整个系统由若干个微服务构成，开发和维护单个微服务相对简单。每个微服务业务复杂度低，方便理解、维护和调试。 单个微服务启动快单个微服务代码量少，启动比庞大的项目要快得多。 故障隔离一个微服务出现故障，并不会对其他微服务产生影响。不会向之前的MVC项目一样，由于一个代码的故障，导致全服务瘫痪。 局部修改容易部署某个业务出现修改，只需要单独重新部署该业务所在的服务即可。由于单个微服务的启动和部署的效率远远高出说有服务的部署，所以即做到了高效的上线效率，又做到了将不良有影响降到最低的效果。 业务模块相对独立业务分拆，单个微服务只关注一个特定的业务功能，所以它的业务清晰、代码量较少。并且每个服务还可用不同的框架，不同的语言去实现，服务与服务之间并不会有相互的影响。 由于以上优点，越来越多的企业开始加入分布式系统的门户中。但是由于业务越来越多，越来越大，微服务的问题也逐渐显露出来。最大的问题，就是服务越来越多。这也就意味着，一次服务的发版，可能意味这越来越多的服务需要打包和部署。这重复且繁琐的工作，会大大降低开发者的工作效率。并且也无法很快的做到大量的服务同时打包和部署。 为了解决这个问题，Docker做出了docker-compose来对多个服务容器，进行管理和编排。Harbor也做出配套的容器镜像，用于存储和管理各代码版本的镜像。 Spring Cloud打包Docker镜像到Harbor第一步，安装Docker1sudo curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 第二步，安装docker-compose1sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose 第三步，安装和配置Harbor安装Harbor，并解压到当前文件夹 在线安装包，并解压在当前文件夹 12wget https://github.com/goharbor/harbor/releases/download/v2.4.1/harbor-online-installer-v2.4.1.tgztar xvf harbor-online-installer-v2.4.1.tgz 离线安装包，并解压在当前文件夹 12wget https://github.com/goharbor/harbor/releases/download/v2.4.1/harbor-offline-installer-v2.4.1.tgztar xvf harbor-offline-installer-v2.4.1.tgz 配置Harbor进入harbor文件夹，复制原始模板配置文件1cp harbor.yml.tmpl harbor.yml 修改harbor配置文件1vi harbor.yml harbor配置文件内容 只选取了需要的部分配置，具体可以参考官方文档和harbor.yml.tmpl模板配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102# 修改harbor的启动ip，这里需要依据系统ip设置，不可为localhost和127.0.0.1hostname: xxx.xxx.xxx.xxxhttp: # 设置HTTP的端口号码，默认为80 port: 80# https配置#https: # 设置HTTPS的端口号码，默认为443 # port: 443 # https证书 # certificate: /data/ssl/harbor.pem # 私钥 # private_key: /data/ssl/harbor.key# Remember Change the admin password from UI after launching Harbor.harbor_admin_password: wall1qaz2wsx# Harbor DB 配置database: # HarborDB密码 password: wall1qaz2wsx # The maximum number of connections in the idle connection pool. If it &lt;=0, no idle connections are retained. max_idle_conns: 100 # The maximum number of open connections to the database. If it &lt;= 0, then there is no limit on the number of open connections. # Note: the default number of connections is 1024 for postgres of harbor. max_open_conns: 900# 默认数据存储位置data_volume: /data# Trivy configuration## Trivy DB contains vulnerability information from NVD, Red Hat, and many other upstream vulnerability databases.# It is downloaded by Trivy from the GitHub release page https://github.com/aquasecurity/trivy-db/releases and cached# in the local file system. In addition, the database contains the update timestamp so Trivy can detect whether it# should download a newer version from the Internet or use the cached one. Currently, the database is updated every# 12 hours and published as a new release to GitHub.trivy: # ignoreUnfixed The flag to display only fixed vulnerabilities ignore_unfixed: false # skipUpdate The flag to enable or disable Trivy DB downloads from GitHub # You might want to enable this flag in test or CI/CD environments to avoid GitHub rate limiting issues. # If the flag is enabled you have to download the `trivy-offline.tar.gz` archive manually, extract `trivy.db` and # `metadata.json` files and mount them in the `/home/scanner/.cache/trivy/db` path. skip_update: false # insecure The flag to skip verifying registry certificate insecure: false # 定时任务jobservice: # 最大的定时任务个数 max_job_workers: 10# 消息通知notification: # webhook最大重试次数 webhook_job_max_retry: 10chart: # Change the value of absolute_url to enabled can enable absolute url in chart absolute_url: disabled# 日志配置log: # 日志等级，debug, info, warning, error, fatal level: info # configs for logs in local storage local: # Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated. rotate_count: 50 # Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes. # If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G # are all valid. rotate_size: 200M # The directory on your host that store log location: /var/log/harbor# 此属性用于程序检测的.cfg文件版本, 请勿改动_version: 2.4.0# Global proxy# Config http proxy for components, e.g. http://my.proxy.com:3128# Components doesn't need to connect to each others via http proxy.# Remove component from `components` array if want disable proxy# for it. If you want use proxy for replication, MUST enable proxy# for core and jobservice, and set `http_proxy` and `https_proxy`.# Add domain to the `no_proxy` field, when you want disable proxy# for some special registry.proxy: http_proxy: https_proxy: no_proxy: components: - core - jobservice - trivy 执行Harbor安装脚本1./install.sh 运行安装脚本，会根据配置文件自动生成Harbor服务的docker-compose.yml文件。 并且会根据当期目录下的 docker-compose.yml开始下载依赖的镜像，检测并按照顺序依次启动各个服务，Harbor依赖的镜像及启动服务如下： 1234567891011121314151617# docker imagesgoharbor/harbor-exporter v2.4.1 0ee361b5454a 3 weeks ago 82.7MBgoharbor/chartmuseum-photon v2.4.1 337a9d03b197 3 weeks ago 174MBgoharbor/redis-photon v2.4.1 2bbe19b8cc5d 3 weeks ago 156MBgoharbor/trivy-adapter-photon v2.4.1 d39fd42c93f0 3 weeks ago 151MBgoharbor/notary-server-photon v2.4.1 e75c68b6638b 3 weeks ago 111MBgoharbor/notary-signer-photon v2.4.1 17a627caf6dd 3 weeks ago 108MBgoharbor/harbor-registryctl v2.4.1 bff3d2665456 3 weeks ago 137MBgoharbor/registry-photon v2.4.1 b46e45c49d6f 3 weeks ago 79.2MBgoharbor/nginx-photon v2.4.1 78aad8c8ef41 3 weeks ago 45.7MBgoharbor/harbor-log v2.4.1 c86562daee64 3 weeks ago 160MBgoharbor/harbor-jobservice v2.4.1 d8baceb5f1f6 3 weeks ago 220MBgoharbor/harbor-core v2.4.1 80a4e3e60403 3 weeks ago 198MBgoharbor/harbor-portal v2.4.1 1c9ed1cc3cb9 3 weeks ago 54.7MBgoharbor/harbor-db v2.4.1 417d0a840247 3 weeks ago 222MBgoharbor/prepare v2.4.1 e9158d34970b 3 weeks ago 257MB 12345678910111213# docker-compose ps Name Command State Ports---------------------------------------------------------------------------------------------harbor-core /harbor/entrypoint.sh Up (healthy)harbor-db /docker-entrypoint.sh 96 13 Up (healthy)harbor-jobservice /harbor/entrypoint.sh Up (healthy)harbor-log /bin/sh -c /usr/local/bin/ ... Up (healthy) 127.0.0.1:1514-&gt;10514/tcpharbor-portal nginx -g daemon off; Up (healthy)nginx nginx -g daemon off; Up (healthy) 0.0.0.0:80-&gt;8080/tcpredis redis-server /etc/redis.conf Up (healthy)registry /home/harbor/entrypoint.sh Up (healthy)registryctl /home/harbor/start.sh Up (healthy) 尝试访问Harbor访问地址为harbor.yml配置的，**{hostname}:{端口号}，例如：192.168.0.1:80** 账号为：admin 密码为：为harbor.yml配置的**harbor_admin_password** 尝试docker登录1234sudo docker login 192.168.0.1:80# 如果没问题，可以注销登录sudo docker logout 192.168.0.1:80 编辑docker的配置编辑客户机/etc/docker/daemon.json文件 123{ &quot;insecure-registries&quot;:[&quot;192.168.0.1:80&quot;]} 重启docker 1systemctl restart docker 第四步，配置maven的setting.xml123456789101112&lt;servers&gt; &lt;server&gt; &lt;!-- 该处ID在后面项目pom文件件配置中用的到 --&gt; &lt;id&gt;docker-harbor&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;!--密码为harbor.yml里设置的harbor_admin_password --&gt; &lt;password&gt;xxxxxx&lt;/password&gt; &lt;configuration&gt; &lt;email&gt;xxxxxxxxx@163.com&lt;/email&gt; &lt;/configuration&gt; &lt;/server&gt;&lt;/servers&gt; 第五步，配置Spring Cloud/Spring Boot项目POM文件项目POM - 增加多个properties子节点12345678&lt;!-- harbor --&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;docker.repository&gt;192.168.0.1:80&lt;/docker.repository&gt; &lt;!-- harbor前端中配置的项目名称 --&gt; &lt;docker.registry.name&gt;dp-cloud-test&lt;/docker.registry.name&gt;&lt;/properties&gt; 项目POM - 增加一个plugin节点123456789101112131415161718192021&lt;!-- harbor push --&gt;&lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;imageName&gt;${docker.repository}/${docker.registry.name}/${project.artifactId}:${project.version}&lt;/imageName&gt; &lt;!-- 指定Dockerfile所在的路径 --&gt; &lt;dockerDirectory&gt;${project.basedir}/src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;${project.build.directory}&lt;/directory&gt; &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 这里的serverId是第四步maven - setting.xml配置中的id --&gt; &lt;serverId&gt;docker-harbor&lt;/serverId&gt; &lt;registryUrl&gt;${docker.repository}&lt;/registryUrl&gt; &lt;pushImage&gt;true&lt;/pushImage&gt; &lt;/configuration&gt;&lt;/plugin&gt; 第六步，配置Spring Cloud/Spring Boot项目中的Dockerfile1234567# 下载对应的jdk版本FROM openjdk:11WORKDIR /# 该处XXXX.jar请改为真实的jar包名称 ${project.build.finalName}.jarADD /XXXX.jar /# 该处XXXX.jar请改为真实的jar包名称 ${project.build.finalName}.jarENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;XXXX.jar&quot;] 第七步，运行maven的install命令出现如下命令行，则表示maven打包、docker打包镜像、推送Harbor成功 12345678910111213141516..........3bb5258f46d2: Pushing [===============================================&gt; ] 328.2MB/342.7MB3bb5258f46d2: Pushing [================================================&gt; ] 331.5MB/342.7MB3bb5258f46d2: Pushing [================================================&gt; ] 334.9MB/342.7MB3bb5258f46d2: Pushing [=================================================&gt; ] 338.2MB/342.7MB3bb5258f46d2: Pushing [==================================================&gt;] 343.2MB3bb5258f46d2: Pushed 1.0: digest: sha256:ca2762ebe83a033fe786b6c16accb4d6a20791a4fcea08c71282bcf8d83ade61 size: 2007null: null [INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 01:07 min[INFO] Finished at: 2022-01-08T04:43:06+08:00[INFO] ------------------------------------------------------------------------","link":"/2022/01/08/Spring%20Cloud%E6%89%93%E5%8C%85Docker%E9%95%9C%E5%83%8F%E5%88%B0Harbor/"},{"title":"Vue中v-for配合key使用的重要性","text":"在 Vue 官网的风格指南中，有很多对于Vue编码的风格的要求和建议。在这里，主要解释在编码指南中，为优先级A：必要的 的编码规范的 为 v-for 设置键值 相信在编码初期，很多人都不理解 key 的作用，因为似乎有与没有，似乎都能完成元素的渲染。（当然，用过 Vue CLI，并设置了 ESlint 的朋友，应该会发现 ESLint 强制要求我们在使用 v-for 时，加入 key，否则在编译阶段会报错） 在官网文档中，对 key 做出的诠释是： 如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。 由官方文档，则说明了 key 在 v-for 渲染的元素中，主要是作为唯一标识去让 Vue “认为”每个元素都是独一无二的，而不会因为为了减小渲染而复用或修改之前相类似的元素，而导致一些特殊情况的出现。 不使用key的情况12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;NewFruitName&quot;&gt; &lt;!-- 双向绑定文本框的输入到 NewFruitName --&gt; &lt;button @click=&quot;NewFruit&quot;&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in FruitList&quot;&gt; &lt;!-- &lt;input type=&quot;checkbox&quot;&gt; {{item.name}} --&gt; &lt;input name=&quot;Fruit&quot; type=&quot;radio&quot;&gt; {{item.name}} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，并将其挂载在id为app的div上 var vm = new Vue({ el: '#app', data: { FruitList: [{ id: 1, name: '苹果' }, { id: 2, name: '香蕉' }, { id: 3, name: '橘子' } ], NewFruitId: 3, // 目前已存在的最大水果id为3 NewFruitName: '', // 新的水果名 }, methods: { // 添加一个新的水果 NewFruit() { this.NewFruitId = this.NewFruitId + 1; // unshift方法，是Array对象的方法，可向数组的开头添加一个或更多元素，并返回新的长度 // 在这里用该方法，主要是为了凸显出key的作用和效果，无特殊含义 this.FruitList.unshift({ id: this.NewFruitId, name: this.NewFruitName }) // 由于双向绑定的缘故，为了显示效果，在添加完成后，清空输入框的输入文字 this.NewFruitName = '' } } });&lt;/script&gt; 测试情况在上面这个情况中，当我们选中香蕉，再添加一个榴莲时，会发现，之前选中的香蕉，变为选中苹果这显然不是我们想要的效果，我们预期的效果是添加一个水果后，之前选中的水果不会变化。 使用key的情况12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;NewFruitName&quot;&gt; &lt;!-- 双向绑定文本框的输入到 NewFruitName --&gt; &lt;button @click=&quot;NewFruit&quot;&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li v-for=&quot;item in FruitList&quot; :key=&quot;item.id&quot;&gt; &lt;!-- &lt;input type=&quot;checkbox&quot;&gt; {{item.name}} --&gt; &lt;input name=&quot;Fruit&quot; type=&quot;radio&quot;&gt; {{item.name}} &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，并将其挂载在id为app的div上 var vm = new Vue({ el: '#app', data: { FruitList: [{ id: 1, name: '苹果' }, { id: 2, name: '香蕉' }, { id: 3, name: '橘子' } ], NewFruitId: 3, // 目前已存在的最大水果id为3 NewFruitName: '', // 新的水果名 }, methods: { // 添加一个新的水果 NewFruit() { this.NewFruitId = this.NewFruitId + 1; // unshift方法，是Array对象的方法，可向数组的开头添加一个或更多元素，并返回新的长度 // 在这里用该方法，主要是为了凸显出key的作用和效果，无特殊含义 this.FruitList.unshift({ id: this.NewFruitId, name: this.NewFruitName }) // 由于双向绑定的缘故，为了显示效果，在添加完成后，清空输入框的输入文字 this.NewFruitName = '' } } });&lt;/script&gt; 测试情况在上面这个情况中，但我们选中香蕉，再添加一个榴莲时，则没有出现选中的水果错位的情况。这和我们的预期一样。 分析原因综上所述，使用 key，在 v-for 渲染的元素中，在某些情况下，出现和预期不一样的效果。这就是因为，在 Vue渲染 的时候，通过只修改元素中的文字，而不重新生成整个元素，来减小渲染强度（只改变元素的2个文字，再添加一个元素，相比于摧毁所有元素，并重新创建所有元素，显然是前者渲染强度小一些。） 关于ESLint的一些观点在现在大多数的情况下，我们都会使用 Vue CLI 来完成项目，在 Vue CLI 中可以选用 ESLint 来对代码进行一些格式规范、和编码规范。当然，它有些时候对于编码的格式太过于严苛，而导致很多初期使用的人，会很头疼，这里可以推荐使用 VSCode 配合Prettier 插件，在保存时，进行自动格式调整。减小在格式调整上花的时间，又同时可以让 ESLint 对编码进行一些检测，比如上面的例子，在 v-for 中，不使用 key，则会不通过检测，并给出相应的提示。","link":"/2020/07/12/Vue%E4%B8%ADv-for%E9%85%8D%E5%90%88key%E4%BD%BF%E7%94%A8%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/"},{"title":"Vue中v-if和v-show的区别和使用场景","text":"我们在学习Vue的时候，肯定产生过对 v-if 和 v-show 的区别存在疑惑。在不深入到渲染逻辑的情况下，大到时候，给开发者的直观感受都是一样的：显示和不显示。但在实现的本质上，是有差别的。 其实在Vue的官方文档中，也有做出一些相应的解释。 概念和区别官方文档概念v-if v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。1 v-show v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。 区别根据以上的官方文档，其实就已经表明出了其背后的渲染逻辑。 v-if 是根据表达式返回的值，来判断是否渲染，更准确的说是，假如表达式返回值为 false，则直接跳过该元素及其子元素的渲染，根本不消耗资源去生成相应的 Virtual DOM。换句话说，v-if 的表达式返回值，会直接触发到 当前组件 生命周期，并且事件监听器和子组件会被适当地被销毁和重建。所以，可以理解为 v-if 是惰性的，他不会在页面初始化时，被无条件渲染，而是按需响应式地渲染。 而 v-show ，这是无论表达式返回值是否是 true 都会在 create 生命周期，无条件消耗资源生成对应的 Virtual DOM，并挂载到HTML页面中，只是再根据表达式返回值，切换 display 这个 CSS 属性。 使用场景从页面显示上看，二者并没有太多的区别，基本上就是显示和不显示的用户体验差别。在需要频繁切换显示状态的组件或者相对渲染强度大但是过分依赖生命周期或的组件，更加适合用 v-show 作为切换的指令。因为，v-if 会带来实时渲染所带来的不必要的资源消耗，和操作延迟，这给用户的体验并不是很好，相对下，v-show基于CSS的显示与隐藏，更加快捷，响应速度更快，并且资源消耗也会更小。但 v-show 的弱点也很明显，因为页面是在页面初始化的时候，就得完成全部的渲染，这使得页面的加载会更消耗资源，也意味着页面加载时长会相应增长。假如组件对资源的消耗，已经影响到了用户的体验，可能采取 v-if 将组件分成小块，按需加载或许会更加有用户体验。 总而言之，v-if 是在表达式返回值切换时，才渲染和摧毁组件及其子组件，他会触发组件的生命周期。而 v-show 是在页面初始化时就进行了完整的渲染，这会在某些情况下，明显增加页面的加载时间。具体的使用，还得根据需求、页面的加载时长以及组件的渲染强度，进行合适的选择。","link":"/2020/07/05/Vue%E4%B8%ADv-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"},{"title":"WSL2安装Centos7","text":"WSL2 安装 Centos7前言 在很多的开发中，我们使用CentOS的比重还是很大的，但是微软官方并没有提供CentOS系统的直接安装但是所幸的是，我们可以使用LxRunOffline这个第三方工具进行CentOS的安装 第一步，安装Chocolatey，并安装LxRunOffline Chocolatey是Windows下一款命令行包管理软件，简单说这就是 Windows的apt-get和yum 以管理员权限打开PowerShell运行以下命令1Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 检验Chocolatey是否安装成功1choco 如果显示出了如下的Chocolatey版本号，则表示安装成功 12Chocolatey v0.12.0Please run 'choco -?' or 'choco &lt;command&gt; -?' for help menu. 安装LxRunOffline LxRunOffline 是非常实用的 WSL 管理软件，可以备份、创建、恢复、导出WSL子系统，也可以安装适配 WSL 的任何 Linux 发行版，可以将 WSL 子系统安装到任意目录中 1choco install -y lxrunoffline 下载后需要重启PowerShell 第三步，GitHub中下载CentOS对应镜像，解压并安装下载CentOS对应镜像该处下载CentOS7.9 1https://github.com/mishamosher/CentOS-WSL/releases/download/7.9-2009/CentOS7.zip 如果需要下载其他版本，可以在此处查看 1https://github.com/mishamosher/CentOS-WSL/releases 解压压缩包，并使用LxRunOffline安装CentOS1LxRunOffline install -n CentOS -d D:/CentOS7_Root -f E:\\CentOS7\\rootfs.tar.gz -d后为系统安装后的目录-f后为刚刚下载的安装包解压的目录里的rootfs.tar.gz地址 设置CentOS的发行版本为WSL21wsl --set-version CentOS 2","link":"/2022/01/17/WSL2%E5%AE%89%E8%A3%85Centos7/"},{"title":"WSL的CentOS7报错Failed to get D-Bus connection Operation not permitted解决办法","text":"WSL的CentOS7报错Failed to get D-Bus connection: Operation not permitted解决办法 WSL的CentOS7使用systemctl和service命令时报错Failed to get D-Bus connection: Operation not permitted, 解决办法是更换systemctl文件 第一步，备份systemctl文件1mv /usr/bin/systemctl /usr/bin/systemctl.old 第二步，下载systemctl脚本1curl https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl.py &gt; /usr/bin/systemctl 第三步，给新下载的脚本赋权1chmod +x /usr/bin/systemctl","link":"/2022/01/17/WSL%E7%9A%84CentOS7%E6%8A%A5%E9%94%99Failed-to-get-D-Bus-connection-Operation-not-permitted%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":".gitignore 无效的解决方案","text":"我们在使用git的时候，经常会使用.gitignore文件，定义规则，对项目文件进行上传筛选但在某些时候，我们可能会出现在项目已经创建，或者项目的中途，创建该文件，而导致的改文件无法生效的情况。 这是因为 .gitignore 只能忽略那些原来没有被 track 的文件，如果某些文件已经被纳入了版本管理中，则修改 .gitignore 是无效的。我们可以尝试用清除本地缓存的方法，解决该问题。 1234git rm -r --cached .git add .git commit -m &quot;update .gitignore&quot;git push -u origin master","link":"/2020/06/21/gitignore%20%E6%97%A0%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":".Net Core3.1 WebAPI CORS跨域配置——踩坑","text":"之前在用Vue开发的过程中，使用到了.Net Core 3.1 的 WebAPI，然后必然要解决一个 CORS 跨域的问题。根据百度，学习到了配置配置跨域的方法。一运行项目访问接口，就直接在Startup类中直接报错 报错异常如下图1234System.InvalidOperationException HResult=0x80131509 Message=The CORS protocol does not allow specifying a wildcard (any) origin and credentials at the same time. Configure the CORS policy by listing individual origins if credentials needs to be supported. Source=Microsoft.AspNetCore.Cors 其实解决方案也很简单： 在Startup类的ConfigureServices方法中添加如下代码： 1234567891011//添加cors 服务 配置跨域处理 services.AddCors(options =&gt;{ options.AddPolicy(&quot;any&quot;, builder =&gt; { builder.WithMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;HEAD&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;) //.AllowCredentials()//指定处理cookie .AllowAnyOrigin(); //允许任何来源的主机访问 });}); 在Startup类的Configure方法中添加如下代码：12app.UseCors(&quot;any&quot;);// 注意，这一行代码一定要写在 app.UseAuthorization(); 的下面，否则会报错的。 以上就是 .Net Core3.1 CORS跨域配置的解决方案。","link":"/2020/06/23/net%20core3.1%20CORS%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE%E2%80%94%E2%80%94%E8%B8%A9%E5%9D%91/"},{"title":"教你如何快速刷网课","text":"这段时间，疫情之下，直播课、网课，得到了空前的发展和壮大。并且应运出很多奇葩的课程，“大学生体育”，里面教你怎么打篮球，怎么打羽毛球，然而，却根本没人可以在家中完成以上联系。“体育”竟然变成了一种偏理论的课程，并且长达十几个小时。实在诙谐。 于是，在朋友的介绍下，我得知了一个惊天地泣鬼神的快速刷完网课的方式——“代刷网课“. 代刷网课“代刷网课”这个产业，在疫情期间，得到了越多人的认可。因为他可以为学生节省很多的时间，去完成一些他们愿意做的事情，比如我放弃了奇葩的”大学生体育”，学习Vue3和Nuxt.js，这十几个小时，可以完成太多的事情。而请”代刷“的成本，却不过2-3元不等，何乐而不为呢？ 我相信大多数人都明白，有些课程的意义是真的对于不感兴趣的人而言，是没有价值的。只会增加大学的心理负担。而刷网课，虽然表面不光鲜亮丽，但却是一种很好的方式，去节省我们大学期间宝贵的时间。我们可以拿着十几到几十小时不等的时间，去学习自己喜欢的事情，或者和室友朋友花这时间去聊天、娱乐毕竟大学不仅是学习专业知识，更多的是锻炼人际交往的能力。这是进入社会必会的技能。 怎样代刷网课在我的朋友的介绍下，我得知一个专业刷网课的平台，这个刷网课平台是他和几个计算机软件技术专业的朋友，共同搭建和完成的，并且在运营发现月收益可以大于月成本后，他们便一直在维护这个网站的运行，并维护着刷网课脚本的功能。运行至今也有3年的时间了。 刷网课平台地址：点击进入，VicoHu刷网课平台 点击上面链接，进入刷网课平台 你会看到到如下页面： 然后，我们点击蓝色按钮的提交课程 至于选择点击哪一个，则需要依照你需要刷的网课的平台来，例如：超星学习通、智慧树/知到，这些均在爆单网课平台中。 我们拿超星学习通为例，进入后选择学习通/超星，并填写相关信息，和下单数量（一科一份，多科多份） 然后点击查询课程，会弹出一个提示框，我们点击确定按钮 点击上图确定后，耐心等待片刻，会再次弹出一个框，勾选要刷的网课，再“确认选择”，然后点击“立刻购买”即可。 然后，便根据下方的提示，不要在手机或电脑上频繁登录账号，一般网课根据时长1-3天不等，便可以刷完。 在选择商品时，可以看到有“代刷”，“高质量代刷”和”秒刷 超级速“， 3种类别，”代刷“就是最普通的刷网课，速度中等一般2-3天刷完，相对比较稳定。“高质量代刷”。是销量最好的，也是老用户最喜欢的刷课选项，速度1-2天左右刷完，速度相对较快，极其稳定，上线至今0失误。”秒刷 超级速“这款是针对网课快要截止的用户，可以在几小时到半天时间内刷完网课，速度极快。 为什么要代刷网课，为什么出现代刷网课（我的一点思考和见解）本质上，学生想刷网课嘛？其实是不想的，他们心里会背负一种内疚感。如果你里面放的是他们想要的东西，感兴趣的东西，或者是真的对未来有可见价值的东西，我相信绝大部分人都不会拒绝。代刷网课只是一种节省掉低效时间、低价值时间的工具。工具本身又怎么会有错呢。 代刷网课，在我朋友那是副业，在大学生那是工具，而对于我而言是一种新的思考。 思考为什么网课里会出现这样没有什么价值的课程，却依旧有着和其他重要的课程一样的学分？思考为什么我们喊着反对应试教育，要因材施教的情况下，却依旧在网课这没有改善。 我们中国的大学教育者是不是该反思，而不是抱着一种，只要学生看完了，自己任务就完成的心态，去教育学生。而应该更多的去思考，怎么让把一个可能学生不兴趣但一定有价值的课程，变得有趣，变得更有价值，变得让学生更容易接受。我相信，教育的方向绝对不是说让大学生依靠自己的“自觉”去学习。这不过是大学教师给自己台阶，给自己不认真备课的借口。 我承认教育者，有他的辛苦之处，可是哪个行业不辛苦呢？我们软件工程师经常的996，却很多时候拿着和大学的老师有着差不多的工资。但我们会说不加班了吗？不会，因为我们知道，我们不996就意味着，我们丢失了工作，意味着我们不知道下一顿饭在哪。 我们都应该，为自己的职位的职责付出应该的努力。同样，大学生也该为自己省略那些观看对于自己低价值课程的时间。去做自己喜欢的事情，去做有价值的事情，去做那个追逐自己内心的自己。","link":"/2020/05/22/%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%88%B7%E7%BD%91%E8%AF%BE/"}],"tags":[{"name":"C#","slug":"C","link":"/tags/C/"},{"name":".Net","slug":"Net","link":"/tags/Net/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/tags/Kubernetes/"},{"name":"Centos7","slug":"Centos7","link":"/tags/Centos7/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"Nacos","slug":"Nacos","link":"/tags/Nacos/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Spring Cloud","slug":"Spring-Cloud","link":"/tags/Spring-Cloud/"},{"name":"Harbor","slug":"Harbor","link":"/tags/Harbor/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"WebAPI","slug":"WebAPI","link":"/tags/WebAPI/"},{"name":".Net Core3.1","slug":"Net-Core3-1","link":"/tags/Net-Core3-1/"},{"name":"刷网课","slug":"刷网课","link":"/tags/%E5%88%B7%E7%BD%91%E8%AF%BE/"},{"name":"大学生刷网课","slug":"大学生刷网课","link":"/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%88%B7%E7%BD%91%E8%AF%BE/"}],"categories":[{"name":"C#","slug":"C","link":"/categories/C/"},{"name":"Kubernetes","slug":"Kubernetes","link":"/categories/Kubernetes/"},{"name":"Nacos","slug":"Nacos","link":"/categories/Nacos/"},{"name":".Net","slug":"C/Net","link":"/categories/C/Net/"},{"name":"Docker","slug":"Docker","link":"/categories/Docker/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"Spring Cloud","slug":"Spring-Cloud","link":"/categories/Spring-Cloud/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"WSL","slug":"WSL","link":"/categories/WSL/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":".Net Core3.1","slug":"C/Net/Net-Core3-1","link":"/categories/C/Net/Net-Core3-1/"},{"name":"小技巧","slug":"小技巧","link":"/categories/%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"name":"JavaScript","slug":"设计模式/JavaScript","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/JavaScript/"},{"name":"LeetCode","slug":"算法/LeetCode","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/"},{"name":"Java","slug":"算法/LeetCode/Java","link":"/categories/%E7%AE%97%E6%B3%95/LeetCode/Java/"}]}